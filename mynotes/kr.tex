\labeledsection{Logic-Based Knowledge Representation}{sec:kr}
\definition{Semantic Network}{
A semantic network is a \linkterm{directed graph}{directed_graph} for representing knowledge:
\begin{itemize}
    \item \linkterm{nodes}{tree} represent \textbf{objects} and \textbf{concepts} (classes of objects)
    \item \linkterm{edges}{directed_graph} (called links) represent relations between these
\end{itemize}
}{semantic_network}

\definition{Inclusion}{
We call links labeled by \textit{isa} inclusion links or isa links (inclusion of concepts)
}{isa}

\definition{Instance}{
We call links labeled by \textit{inst} instance links or inst links (concept memership)
}{inst}

\definition{Relations in Semantic Nets}{
We call all links labels \textbf{except} \linkterm{isa}{isa} and \linkterm{inst}{inst} in a \linkterm{semantic network}{semantic_network} \textbf{relations}.
}{relations_sn}

\definition{Inference in Semantic Networks}{
Let $N$ be a \linkterm{semantic network}{semantic_network} and $R$ a \linkterm{relation}{relations_sn} in $N$ such that $A \xrightarrow{\linkterm{isa}{isa}} B \xrightarrow{R} C$ or $A \xrightarrow{\linkterm{inst}{inst}} B \xrightarrow{R} C$, then we can derive a \linkterm{relation}{relations_sn} $A \xrightarrow{R} C$ in $N$. The process of deriving new concepts and \linkterm{relation}{relations_sn} from existing ones is called \textbf{inference} and concepts/\linkterm{relation}{relations_sn} that are only available via inference are called \textbf{implicit} in a \linkterm{semantic network}{semantic_network}.
}{inference_sn}

\textbf{Example: } blue are \linkterm{derived}{inference_sn} \linkterm{relations}{relations_sn}, red is not allowed:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\linewidth]{images/derived_relations_sn.png}
    \caption{\linkterm{Inference}{inference_sn} in \linkterm{semantic networks}{semantic_network}}
    \label{fig:derived_relations}
\end{figure}

\definition{TBox}{
We call the subgraph of a \linkterm{semantic network}{semantic_network} $N$ spanned by the \linkterm{isa links}{isa} and \linkterm{relations}{relations_sn} between \textbf{concepts} the \textbf{terminology} (or \textbf{TBox}, or \textbf{Isa Hierarchy}).
}{tbox}

\definition{ABox}{
We call the subgraph of a \linkterm{semantic network}{semantic_network} $N$ spanned by the \linkterm{inst links}{inst} and \linkterm{relations}{relations_sn} between \textbf{objects} the \textbf{assertions} (or \textbf{ABox}).
}{abox}

\textbf{Example: }
\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\linewidth]{images/abox_tbox.png}
    \caption{\linkterm{TBox}{tbox} and \linkterm{ABox}{abox} in \linkterm{semantic networks}{semantic_network}}
    \label{fig:tbox_abox}
\end{figure}

\definition{$\text{PL}^0_{\text{DL}}$}{
We use \linkterm{propositional logic}{def:pl0_as_ls} as a \linkterm{set}{def:set} description language. We define $\text{PL}^0_{\text{DL}}$ by the following \linkterm{grammar}{phrase_structure_grammar} for the $\text{PL}^0_{\text{DL}}$ concepts (formulae):
\[
\mathcal{L} ::= C \mid \top \mid \bot \mid \overline{\mathcal{L}} \mid \mathcal{L} \sqcap \mathcal{L} \mid \mathcal{L} \sqcup \mathcal{L} \mid \mathcal{L} \sqsubseteq \mathcal{L} \mid \mathcal{L} \equiv \mathcal{L}
\]
}{pl0dl}

\linkterm{$\text{PL}^0_{\text{DL}}$}{pl0dl} is formed from:
\begin{itemize}
    \item \linkterm{atomic formulae}{atomic_formula}
    \item concept intersection ($\sqcap$)
    \item concept complement ($\overline{\cdot}$)
    \item concept union ($\sqcup$)
    \item concept subsumption ($\sqsubseteq$), and equivalence ($\equiv$)
\end{itemize}

\definition{Set-Theoretic Semantics of \linkterm{$\text{PL}^0_{\text{DL}}$}{pl0dl}}{
Let $\mathcal{D}$ be a given \linkterm{set}{def:set} (\linkterm{domain of discourse}{domain_of_discourse}) and $\func{\varphi}{\mathcal{V}_{\text{PL}^0}}{\powerset{\mathcal{D}}}$. We define the valuation $\sint{\cdot}$ as:
\begin{itemize}
    \item $\sint{P} := \varphi(P)$ (for atomic concepts)
    \item $\sint{\top} := \mathcal{D}$ and $\sint{\bot} := \emptyset$
    \item $\sint{\overline{A}} := \mathcal{D} \setminus \sint{A}$ 
    \item $\sint{A \sqcap B} := \sint{A} \cap \sint{B}$ 
    \item $\sint{A \sqcup B} := \sint{A} \cup \sint{B}$ 
    \item $\sint{A \sqsubseteq B}$ is satisfied iff $\sint{\overline{A}} \cup \sint{B} = \mathcal{D}$ which is satisfied iff $\sint{A} \subseteq \sint{B}$ 
    \item $\sint{A \equiv B}$ is satisfied iff $\sint{A} = \sint{B}$ 
\end{itemize}
}{set_theoretic_semantics_pl0dl}

\commandnote{
The triple $\langle \text{PL}^0_{\text{DL}}, \mathcal{S}, \sint{\cdot} \rangle$, where $\mathcal{S}$ is the class of possible domains, forms a \linkterm{logical system}{logical_system}.
}

\definition{Concept Axiom}{
A concept axiom is a \linkterm{$\text{PL}^0_{\text{DL}}$}{pl0dl} formula $A$ that is assumed to be true in the world.
}{concept_axiom}

\definition{Set-Theoretic Semantics of Axioms}{
$A$ is true in \linkterm{domain of discourse}{domain_of_discourse} $\mathcal{D}$ iff $\sint{A} = \mathcal{D}$
}{set_theoretic_semantics_axioms}

\commandnote{
Any concept we add to our world is just a \linkterm{set}{def:set}, for example, here is a world with three concepts (no \linkterm{concept axioms}{concept_axiom} yet):

\begin{figure}[H]
    \includegraphics[width=0.4\linewidth]{images/concepts_sets1.png}
\end{figure}

Looks a mess? try to add \linkterm{concept axioms}{concept_axiom}. Here is how it looks like when adding:
\begin{itemize}
    \item $\text{son} \sqsubseteq \text{child}$
    \item $\text{daughter} \sqsubseteq \text{child}$
\end{itemize}

\begin{figure}[H]
    \includegraphics[width=0.2\linewidth]{images/concepts_sets2.png}
\end{figure}

We add two more \linkterm{concept axioms}{concept_axiom}:
\begin{itemize}
    \item $\overline{\text{son} \sqcap \text{daughter}}$
    \item $\text{child} \sqsubseteq \text{son} \sqcup \text{daughter}$
\end{itemize}

\begin{figure}[H]
    \includegraphics[width=0.2\linewidth]{images/concepts_sets3.png}
\end{figure}

}

The set-theoretic semantics is compatible with the regular semantics of \linkterm{propositional logic}{def:pl0_as_ls}, therefore we have the same \linkterm{propositional identities}{identities_pl0}:

\begin{table}[h]
\centering
\caption{\linkterm{$\text{PL}^0_{\text{DL}}$}{pl0dl} Identities}
\label{tab:identities_pl0dl}
\begin{tabular}{|l|c|c|}
\hline
\textbf{Name} & \textbf{for $\sqcap$} & \textbf{for $\sqcup$} \\
\hline
Idempotence      & $\varphi \sqcap \varphi = \varphi$        & $\varphi \sqcup \varphi = \varphi$ \\
Identity         & $\varphi \sqcap \top = \varphi$            & $\varphi \sqcup \bot = \varphi$ \\
Absorption 1     & $\varphi \sqcap \bot = \bot$                & $\varphi \sqcup \top = \top$ \\
Commutativity    & $\varphi \sqcap \psi = \psi \sqcap \varphi$ & $\varphi \sqcup \psi = \psi \sqcup \varphi$ \\
Associativity    & $\varphi \sqcap (\psi \sqcap \theta) = (\varphi \sqcap \psi)\sqcap \theta$  
                 & $\varphi \sqcup (\psi \sqcup \theta) = (\varphi \sqcup \psi)\sqcup \theta$ \\
Distributivity   & $\varphi \sqcap (\psi \sqcup \theta)= (\varphi \sqcap \psi)\sqcup (\varphi \sqcap \theta)$ 
                 & $\varphi \sqcup (\psi \sqcap \theta)= (\varphi \sqcup \psi)\sqcap (\varphi \sqcup \theta)$ \\
Absorption 2     & $\varphi \sqcap (\varphi \sqcup \theta)= \varphi$ 
                 & $\varphi \sqcup (\varphi \sqcap \theta)= \varphi$ \\
De Morgan rule   & $\overline{\varphi \sqcap \psi}= \overline{\varphi} \sqcup \overline{\psi}$ 
                 & $\overline{\varphi \sqcup \psi} = \overline{\varphi} \sqcap \overline{\psi}$ \\
double negation  & \multicolumn{2}{c|}{$\overline{\overline{\varphi}}  = \varphi$} \\
\hline
\end{tabular}
\end{table}


\definition{Translation to \linkterm{$\text{PL}^1$}{pl1}}{
We define the translation of \linkterm{$\text{PL}^0_{\text{DL}}$}{pl0dl} expressions into \linkterm{$\text{PL}^1$}{pl1} using two functions: a recursive mapping $\text{FOL}_x$ for concept expressions and a top-level mapping $\text{FOL}$ for axioms/formulae.
}{mapping_pl0dl_pl1}

\textbf{Recursive mapping for Concepts:}

\begin{tabular}{@{}l@{}}
    $\text{FOL}_x(p) := p(X)$ \\
    $\text{FOL}_x(\overline{A}) := \neg \text{FOL}_x(A)$ \\
    $\text{FOL}_x(A \sqcap B) := \text{FOL}_x(A) \land \text{FOL}_x(B)$ \\
    $\text{FOL}_x(A \sqcup B) := \text{FOL}_x(A) \lor \text{FOL}_x(B)$ \\
    $\text{FOL}_x(A \sqsubseteq B) := \text{FOL}_x(A) \Rightarrow \text{FOL}_x(B)$ \\
    $\text{FOL}_x(A \equiv B) := \text{FOL}_x(A) \Leftrightarrow \text{FOL}_x(B)$ \\
\end{tabular}

\textbf{Mapping for Formulae (calls $\text{FOL}_x$):}
\begin{tabular}{@{}l@{}}
    $\text{FOL}(A) := \forall X. \, \text{FOL}_x(A)$ \\
\end{tabular}

\textbf{Example: }
Let's translate the formula: \textit{"an undergrad is a person who is not a graduate"}. In \linkterm{$\text{PL}^0_{\text{DL}}$}{pl0dl}, we can express this by:
\[
\text{undergrad} \equiv \text{person} \sqcap \overline{\text{graduate}}
\]

\begin{align*}
\text{FOL}(\text{undergrad} \equiv \text{person} \sqcap \overline{\text{graduate}}) &= \forall X. \text{FOL}_x(\text{undergrad} \equiv \text{person} \sqcap \overline{\text{graduate}}) \\
\text{FOL}_x(\text{undergrad} \equiv \text{person} \sqcap \overline{\text{graduate}}) &= \text{FOL}_x(\text{undergrad}) \Leftrightarrow \text{FOL}_x(\text{person} \sqcap \overline{\text{graduate}}) \\
\text{FOL}_x(\text{undergrad}) &= \text{undergrad}(X) \\
\text{FOL}_x(\text{person} \sqcap \overline{\text{graduate}}) &= \text{FOL}_x(\text{person}) \land \text{FOL}_x(\overline{\text{graduate}}) \\
&= \text{person}(X) \land \neg \text{FOL}_x(\text{graduate}) \\
&= \text{person}(X) \land \neg \text{graduate}(X) \\
\text{FOL}(\text{undergrad} \equiv \text{person} \sqcap \overline{\text{graduate}}) &= \forall X. (\text{undergrad}(X) \Leftrightarrow (\text{person}(X) \land \neg \text{graduate}(X)))
\end{align*}

\definition{Ontology}{
An \textbf{ontology} consists of a \linkterm{formal system}{formal_system} $\tuple{\mathcal{L}, \mathcal{M}, \vDash, \mathcal{C}}$ with \linkterm{concept axioms}{concept_axiom} about:
\begin{itemize}
    \item individuals: concrete entities in a \linkterm{domain of discourse}{domain_of_discourse} (instances of concepts)
    \item concepts: particular collections of individuals that share properties and aspects
    \item relations: ways in which individuals can be related to one another
\end{itemize}
}{def:ontology}

\commandnote{
An \textbf{ontology} is a representation of the types, properties, and interrelationships of the entities that really exist for a particular \linkterm{domain of discourse}{domain_of_discourse}
}

\commandnote{
    \begin{itemize}
        \item \linkterm{Semantic networks}{semantic_network} are \linkterm{ontologies}{def:ontology}
        \item \linkterm{$\text{PL}^0_{\text{DL}}$}{pl0dl} is an \linkterm{ontology}{def:ontology} format that is \textit{formal} but \textit{weak}
        \item \linkterm{$\text{PL}^1$}{pl1} is an \linkterm{ontology}{def:ontology} format that is \textit{formal} and \textit{expressive}
    \end{itemize}
}

\definition{Description Logic}{
A description logic (DL) is a \linkterm{formal system}{formal_system} for talking about collections of objects and their relations that is at least as expressive as \linkterm{$\text{PL}^0$}{def:pl0_as_ls} with \linkterm{Set-Theoretic Semantics}{set_theoretic_semantics_pl0dl} and offers individuals and relations.
}{description_logic}

\definition{DL Components}{
A \linkterm{description logic}{description_logic} has the following four components:
\begin{itemize}
\item a \linkterm{formal language}{formal_language} $\mathcal{L}$ with logical constants $\sqcap, \overline{\cdot}, \sqcup, \sqsubseteq, $and $\equiv$
\item a \linkterm{Set-Theoretic Semantics}{set_theoretic_semantics_pl0dl} $\tuple{\mathcal{D}, \sint{\cdot}}$
\item a \linkterm{translation}{mapping_pl0dl_pl1} into \linkterm{$\text{PL}^1$}{pl1} that is compatible with $\tuple{\mathcal{D}, \sint{\cdot}}$
\item a \linkterm{calculus}{calculus_logic} for $\mathcal{L}$ that induces a decision procedure for $\mathcal{L}$-satisfibility
\end{itemize}
}{dl_components}

\definition{Concept Definition}{
Let $\mathcal{D}$ be a \linkterm{description logic}{description_logic} with concepts $\mathcal{C}$ Then a \textbf{concept definition} is a pair $c = C$ where $c$ is a new concept name and $C \in \mathcal{C}$ is a $\mathcal{D}$-formula. Example: $\text{mother} = \text{woman} \sqcap \text{has\_child}$ 
}{concept_definition}

\definition{Recursive Concept Definition}{
A \linkterm{concept definition}{concept_definition} $c = C$ is called \textbf{recursive}, iff $c$ occurs in $C$.
}{recursive_concept_definition}

\definition{Acyclic TBox}{
A \linkterm{TBox}{tbox} is a \linkterm{finite}{set_cardinality} \linkterm{set}{def:set} of \linkterm{concept definitions}{concept_definition} and \linkterm{concept axioms}{concept_axiom}. It is called \textbf{acyclic}, iff it does not contain \linkterm{recursive definitions}{recursive_concept_definition}.
}{acyclic_tbox}

\definition{}{
A formula $A$ is called \textbf{normalized} w.r.t. a \linkterm{TBox}{tbox} $\mathcal{T}$, iff it does not contain concepts defined in $\mathcal{T}$.
}{}

\definition{}{
\linkterm{Ontology}{def:ontology} systems employ three main kinds of inference / reasoning:
\begin{itemize}
    \item Consistency test: is a \linkterm{concept definition}{concept_definition} \linkterm{satisfiable}{satisfiable_ls}
    \item Subsumption test: does a concept subsume another?
    \item Instance test: is an individual an example of a concept?
\end{itemize}
}{}

\definition{Consistent Concept}{
We call a concept $C$ consistent, iff there is no concept $A$ with both $C \sqsubseteq A$ and $C \sqsubseteq \overline{A}$
}{consistent_concept}

\definition{Inconsistent Concept}{
A concept $C$ is called inconsistent, iff $\sint{C} = \emptyset$ for all $\mathcal{D}$.
}{inconsistent_concept}

For example, consider we have the following \linkterm{TBox}{tbox} in \linkterm{$\text{PL}^0_{\text{DL}}$}{pl0dl}:
\begin{itemize}
    \item $\text{man} = \text{person} \sqcap \text{has\_Y}$
    \item $\text{woman} = \text{person} \sqcap \overline{\text{has\_Y}}$
    \item $\text{hermaphrodite} = \text{man} \sqcap \text{woman}$
\end{itemize}
the concept $\text{hermaphrodite}$ is \linkterm{inconsistent}{inconsistent_concept} since $\sint{\text{hermaphrodite}} = \emptyset$ for all $\mathcal{D}$

\commandnote{
We test satisfiability using tableaux, resolution, DPLL in \linkterm{$\text{PL}^0_{\text{DL}}$}{pl0dl}
}


\definition{Subsumption}{
$A$ subsumes $B$ (modulo a set $\mathcal{A}$ of \linkterm{concept axioms}{concept_axiom}), iff $\sint{B} \subseteq \sint{A}$ for all interpretations $\mathcal{D}$ that satisfy $\mathcal{A}$. Equivalently, iff $\mathcal{A} \sqsubseteq B \sqsubseteq A = T$
}{subsumes}

\commandnote{
Subsumption tests reduce to consistency tests because in \linkterm{$\text{PL}^0$}{def:pl0_as_ls}, $\mathcal{A} \Rightarrow (A \Rightarrow B)$ is \linkterm{valid}{valid_ls} iff $\mathcal{A} \land A \land \neg B$ is \linkterm{inconsistent}{inconsistent_concept}.
}

\textbf{Example: }if we want to know whether $\text{man} \sqsubseteq \text{person}$ in the previous \linkterm{TBox}{tbox}, we check the consistency of $\text{man} \land \neg \text{person}$. $\text{person} \land \text{has\_Y} \land \neg \text{person}$ is \linkterm{inconsistent}{inconsistent_concept}, hence $\text{man} \sqsubseteq \text{person}$.


\definition{Instance Test}{
An instance test computes, given an \linkterm{ontology}{def:ontology}, whether an individual is a \linkterm{member}{def:set} of a given concept.
}{instance_test_dl}

\commandnote{
This is not something that we can do in \linkterm{$\text{PL}^0_{\text{DL}}$}{pl0dl} because it is a \linkterm{TBox}{tbox} only system.
}

\definition{$\mathcal{ALC}$ Syntax}{
The formulae of $\mathcal{ALC}$ are given by the following grammar:
\[
F_{\mathcal{ALC}} ::= C \mid \top \mid \bot \mid   
F_{\mathcal{ALC}} \sqcap F_{\mathcal{ALC}} \mid   
F_{\mathcal{ALC}} \sqcup F_{\mathcal{ALC}} \mid
\exists R. F_{\mathcal{ALC}} \mid
\forall R. F_{\mathcal{ALC}}
\]
}{alc_grammar}

\commandnote{
\begin{itemize}
\item  \linkterm{$\text{PL}^0$}{def:pl0_as_ls} is not expressive enough
\item \linkterm{$\text{PL}^1$}{pl1} is too expressive and not decidable
\item Middle ground $\leadsto \mathcal{ALC}$
\item $\mathcal{ALC}$ is a simple \linkterm{description logic}{description_logic}
\item It is more expressive than \linkterm{$\text{PL}^0$}{def:pl0_as_ls} but weaker than \linkterm{$\text{PL}^1$}{pl1}
\item It allows us to quantify only over \linkterm{finite}{set_cardinality} \linkterm{sets}{def:set} (unline \linkterm{$\text{PL}^1$}{pl1} where we quantify over \linkterm{$V_{\iota}$}{fol_sig_pl1} which is \linkterm{infinite}{set_cardinality})
\item Restricted quantification: the quantified variables in $\mathcal{ALC}$ only range over values that can be reached via binary relations such as \texttt{has\_child}
\end{itemize}
}

\definition{Role}{
A role represent a binary relation (like in \linkterm{$\text{PL}^1$}{pl1})
}{role_alc}

\textbf{Syntax Examples}:

\begin{itemize}
\item $\text{person} \sqcap (\exists \text{has\_child.student})$

This means the \linkterm{set}{def:set} of persons that have a child which is a student, i.e. parents of students

\item $\text{person} \sqcap (\exists \text{has\_child.}\exists \text{has\_child.student})$

grandparents of students

\item $\text{person} \sqcap (\exists \text{has\_child.}\exists \text{has\_child.student}\sqcup \text{teacher})$

grandparents of students or teachers

\item $\text{person} \sqcap (\forall \text{has\_child.student})$

parents whose children are \textbf{all} students 

\item $\text{person} \sqcap (\forall \text{has\_child}.\exists \text{has\_child.student})$

grandparents, whose children \textbf{all} have \textbf{at least} one child that is a student

\item $\text{car} \sqcap \exists \text{has\_parts}.\exists \text{made\_in}. \overline{\text{EU}}$

cars that have at least one part that has not been made in the EU 

\item $\text{student} \sqcap \forall \text{audit\_course.graduatelevelcourse}$

students that \textbf{all} the courses they audit are graduate level courses

\item $\text{house} \sqcap \forall \text{has\_parkig.off\_street}$

houses with only off-street parking

\item $\text{student} \sqcap \forall \text{audit\_course}.(\exists \text{has\_tutorial}.\top \sqsubseteq \forall \text{has\_TA.woman})$ \hfill remember $A \sqsubseteq B \equiv \overline{A} \sqcup B$

students that only audit courses that either have no tutorials or tutorials that are TAed by women
\end{itemize}


\definition{Concept Definition in \linkterm{$\mathcal{ALC}$}{alc_grammar}}{
A concept definition is a pair consisting of a new concept name (the \linkterm{defineiendum}{defineiendum}) and an \linkterm{$\mathcal{ALC}$}{alc_grammar} formula (the \linkterm{definiens}{definiens}). Concepts that are not \linkterm{defineienda}{defineiendum} are called \textbf{primitive}
}{concept_definition_alc}

\commandnote{
We extend the \linkterm{$\mathcal{ALC}$ grammar}{alc_grammar} from \defref{alc_grammar} by the following:
\[
\text{CD}_{\linkterm{\mathcal{ALC}}{alc_grammar}} ::= C = F_{\linkterm{\mathcal{ALC}}{alc_grammar}}
\]
So it becomes:
\begin{align*}
F_{\mathcal{ALC}} &::= C \mid \top \mid \bot \mid   
F_{\mathcal{ALC}} \sqcap F_{\mathcal{ALC}} \mid   
F_{\mathcal{ALC}} \sqcup F_{\mathcal{ALC}} \mid
\exists R. F_{\mathcal{ALC}} \mid
\forall R. F_{\mathcal{ALC}} \\ 
\text{CD}_{\mathcal{ALC}} &::= C = F_{\mathcal{ALC}}
\end{align*}
}

\linkterm{Concept definitions}{concept_definition_alc} Examples:
\begin{itemize}
\item $\text{man} = \text{person} \sqcap \exists \text{has\_chrom.Y\_chrom}$

meaning, a man is a perosn who has at lease one Y chromosome. \texttt{person} here is a \linkterm{primitive concept}{concept_definition_alc}

\item $\text{woman} = \text{person} \sqcap \forall \text{has\_chrom}.\overline{\text{ Y\_chrom}}$
\item $\text{mother} = \text{woman} \sqcap \exists \text{has\_child.person}$
\item $\text{father} = \text{man} \sqcap \exists \text{has\_child.person}$
\item $\text{grandparent} = \text{person} \sqcap \exists \text{has\_child}.(\text{mother} \sqcup \text{father})$
\end{itemize}

\definition{}{
We call an \linkterm{$\mathcal{ALC}$}{alc_grammar} formula $\varphi$ \textbf{normalized} w.r.t. a \linkterm{set}{def:set} of \linkterm{concept definitions}{concept_definition_alc}, iff all concepts occuring in $\varphi$ are \linkterm{primitive}{concept_definition_alc}.
}{normalized_formula_alc}

\definition{Normalization}{
Given a set $\mathcal{D}$ of \linkterm{concept definitions}{concept_definition_alc}, \textbf{normalization} is the process of replacing in an \linkterm{$\mathcal{ALC}$}{alc_grammar} formula $\varphi$ all occurences of \linkterm{defineienda}{defineiendum} in $\mathcal{D}$ with their \linkterm{definientia}{definiens}.
}{normalization_alc}

\textbf{Example: }\linkterm{normalization}{normalization_alc} of \texttt{grandparent}:
\begin{itemize}
\item $\text{grandparent} = \text{person} \sqcap \exists \text{has\_child}.(\text{mother} \sqcup \text{father})$
\item $\text{grandparent} = \text{person} \sqcap \exists \text{has\_child}.(\text{woman} \sqcap \exists \text{has\_child.person} \sqcup \text{man} \sqcap \exists \text{has\_child.person})$
\item $\text{grandparent} = \text{person} \sqcap \exists \text{has\_child}.(\text{person} \sqcap \forall \text{has\_chrom}.\overline{\text{ Y\_chrom}} \sqcap \exists \text{has\_child.person} \sqcup  \text{person} \sqcap \exists \text{has\_chrom.Y\_chrom} \sqcap \exists \text{has\_child.person})$
\end{itemize}

\commandnote{
\begin{itemize}
    \item \linkterm{Normalization}{normalization_alc} results can be exponential.
    \item \linkterm{Normalization}{normalization_alc} need not to terminate on cyclic \linkterm{TBoxes}{tbox}
\end{itemize}
}

\definition{\linkterm{$\mathcal{ALC}$}{alc_grammar} Semantics}{
\linkterm{$\mathcal{ALC}$}{alc_grammar} Semantics is an extension of the \linkterm{Set-Theoretic Semantics}{set_theoretic_semantics_pl0dl} of \linkterm{$\text{PL}^0$}{def:pl0_as_ls}.
}{alc_semantics}

\definition{\linkterm{$\mathcal{ALC}$}{alc_grammar} Interpretation}{
A \textbf{model} for \linkterm{$\mathcal{ALC}$}{alc_grammar} is a pair $\tuple{\mathcal{D}, \sint{\cdot}}$, where $\mathcal{D}$ is a non-empty \linkterm{set}{def:set} (\linkterm{domain of discourse}{domain_of_discourse}) and $\sint{\cdot}$ is the interpretation such that:
\begin{itemize}
    \item $\sint{\top} = \mathcal{D}, \quad \sint{\bot} = \emptyset, \quad \sint{r} \subseteq \cartprod{\mathcal{D},\mathcal{D}}$
    \item $\sint{\overline{\varphi}} = \overline{\sint{\varphi}} = \mathcal{D} \setminus \sint{\varphi}$
    \item $\sint{\varphi \sqcap \psi} = \sint{\varphi} \cap \sint{\psi}$
    \item $\sint{\varphi \sqcup \psi} = \sint{\varphi} \cup \sint{\psi}$
    \item $\sint{\exists R.\varphi} = \set{x \in \mathcal{D} \mid \exists y. \tuple{x,y} \in \sint{R} \land y \in \sint{\varphi}}$
    \item $\sint{\forall R.\varphi} = \set{x \in \mathcal{D} \mid \forall y. \tuple{x,y} \in \sint{R} \Rightarrow y \in \sint{\varphi}}$
\end{itemize}
}{alc_interp}

\definition{\linkterm{$\mathcal{ALC}$}{alc_grammar} to \linkterm{$\text{PL}^1$}{pl1} Translation}{
The translation of \linkterm{$\mathcal{ALC}$}{alc_grammar} into \linkterm{$\text{PL}^1$}{pl1} extends the one from \defref{mapping_pl0dl_pl1} by the following quantifier rules:

\begin{tabular}{@{}l@{}}
$\text{FOL}_x(\forall R. \varphi) := (\forall Y. R(X,Y) \Rightarrow \text{FOL}_(\varphi))$\\
$\text{FOL}_x(\exists R. \varphi) := (\exists Y. R(X,Y) \land \text{FOL}_y(\varphi))$ \\
\end{tabular}
}{alc_to_pl1_tr}

\definition{\linkterm{$\mathcal{ALC}$}{alc_grammar} Identities}{
\begin{enumerate}
\item $\overline{\exists R. \varphi} = \forall R. \overline{\varphi}$
\item $\forall R. (\varphi \sqcap \psi) = \forall R. \varphi \sqcap \forall R.\psi$
\item $\overline{\forall R. \varphi} = \exists R. \overline{\varphi}$
\item $\exists R. (\varphi \sqcup \psi) = \exists R.\varphi \sqcup \exists R.\psi$ 
\end{enumerate}
}{alc_identities}

\textbf{Proof of (1)}:

\begin{align*}
\sint{\overline{\exists R. \varphi}} &= \overline{\sint{\exists R. \varphi}} = \mathcal{D} \setminus \sint{\exists R. \varphi} \\ 
&= \mathcal{D} \setminus \set{x \in \mathcal{D} \mid \exists y. \tuple{x,y} \in \sint{R} \land y \in \sint{\varphi}} \\ 
&= \set{x \in \mathcal{D} \mid \neg (\exists y. \tuple{x,y} \in \sint{R} \land y \in \sint{\varphi})} \\ 
&= \set{x \in \mathcal{D} \mid \forall y. \neg(\tuple{x,y} \in \sint{R} \land y \in \sint{\varphi})} \qquad \qquad \qquad \neg (A \land B) = \neg A \lor \neg B = A \Rightarrow \neg B \\
&= \set{x \in \mathcal{D} \mid \forall y. \tuple{x,y} \in \sint{R} \Rightarrow y \notin \sint{\varphi}} \\
&= \set{x \in \mathcal{D} \mid \forall y. \tuple{x,y} \in \sint{R} \Rightarrow y \in \sint{\overline{\varphi}}} \\ 
&= \sint{\forall R. \overline{\varphi}}
\end{align*}

\definition{NNF in \linkterm{$\mathcal{ALC}$}{alc_grammar}}{
An \linkterm{$\mathcal{ALC}$}{alc_grammar} formula is in Negation Normal Form (NNF), iff complement ($\overline{\cdot}$) is only applied to \linkterm{primitive concept}{concept_definition_alc}.
}{nnf_alc}
\textbf{Example: } $\overline{\exists R. (\forall S.e \sqcap \overline{\forall S.d})} \leadsto \forall R. \overline{\forall S.e \sqcap \overline{\forall S.d}} \leadsto \forall R. \overline{\forall S.e} \sqcup \overline{\overline{\forall S.d}} \leadsto \forall R. \exists S.\overline{e} \sqcup \forall S.d$

\definition{}{
We define the \textbf{ABox Assertions} for \linkterm{$\mathcal{ALC}$}{alc_grammar}:
\begin{itemize}
    \item $a:\varphi$ \hfill \linkterm{role}{role_alc} assertions ($a$ is a $\varphi$, i.e. \linkterm{instance}{inst} of $\varphi$)
    \item $a \text{ R } b$ \hfill $a$ stands in relation R to $b$
\end{itemize}
assertions make up the \linkterm{ABox}{abox} in \linkterm{$\mathcal{ALC}$}{alc_grammar}
}{abox_assertions_alc}

\definition{}{
We extend \linkterm{$\mathcal{ALC}$ semantics}{alc_semantics} by: 
\begin{itemize}
    \item $\sint{a:\varphi} = T \Leftrightarrow \sint{a} \in \sint{\varphi}$
    \item $\sint{a \text{ R } b} = T \Leftrightarrow (\sint{a}, \sint{b}) \in \sint{R}$
\end{itemize}
}{}

\definition{}{
We extend the \linkterm{translation}{alc_to_pl1_tr} of \linkterm{$\mathcal{ALC}$}{alc_grammar} to \linkterm{$\text{PL}^1$}{pl1} by the following:

\begin{tabular}{@{}l@{}}
$\text{FOL}(a:\varphi) := \text{FOL}_a(\overline{\varphi})$\\
$\text{FOL}(a \text{ R }b) := \text{R}(a,b)$ \\
\end{tabular}
}{}

\commandnote{
\textbf{The complete \linkterm{$\mathcal{ALC}$}{alc_grammar} semantics:}
\begin{itemize}
    \item $\sint{\top} = \mathcal{D}, \quad \sint{\bot} = \emptyset, \quad \sint{r} \subseteq \cartprod{\mathcal{D},\mathcal{D}}$
    \item $\sint{\overline{\varphi}} = \overline{\sint{\varphi}} = \mathcal{D} \setminus \sint{\varphi}$
    \item $\sint{\varphi \sqcap \psi} = \sint{\varphi} \cap \sint{\psi}$
    \item $\sint{\varphi \sqcup \psi} = \sint{\varphi} \cup \sint{\psi}$
    \item $\sint{\exists R.\varphi} = \set{x \in \mathcal{D} \mid \exists y. \tuple{x,y} \in \sint{R} \land y \in \sint{\varphi}}$
    \item $\sint{\forall R.\varphi} = \set{x \in \mathcal{D} \mid \forall y. \tuple{x,y} \in \sint{R} \Rightarrow y \in \sint{\varphi}}$
    \item $\sint{a:\varphi} = T \Leftrightarrow \sint{a} \in \sint{\varphi}$
    \item $\sint{a \text{ R } b} = T \Leftrightarrow (\sint{a}, \sint{b}) \in \sint{R}$
\end{itemize}

\begin{tabular}{@{}l@{}}
    \\
    \textbf{The complete translation:} \\
    $\text{FOL}_x(p) := p(X)$ \\
    $\text{FOL}_x(\overline{A}) := \neg \text{FOL}_x(A)$ \\
    $\text{FOL}_x(A \sqcap B) := \text{FOL}_x(A) \land \text{FOL}_x(B)$ \\
    $\text{FOL}_x(A \sqcup B) := \text{FOL}_x(A) \lor \text{FOL}_x(B)$ \\
    $\text{FOL}_x(A \sqsubseteq B) := \text{FOL}_x(A) \Rightarrow \text{FOL}_x(B)$ \\
    $\text{FOL}_x(A \equiv B) := \text{FOL}_x(A) \Leftrightarrow \text{FOL}_x(B)$ \\
    $\text{FOL}_x(\forall R. \varphi) := (\forall Y. R(X,Y) \Rightarrow \text{FOL}_(\varphi))$\\
    $\text{FOL}_x(\exists R. \varphi) := (\exists Y. R(X,Y) \land \text{FOL}_y(\varphi))$ \\
    \\
    \textbf{For Formulae:} \\
    $\text{FOL}(A) := \forall X. \, \text{FOL}_x(A)$ \\
    $\text{FOL}(a:\varphi) := \text{FOL}_a(\overline{\varphi})$\\
    $\text{FOL}(a \text{ R }b) := \text{R}(a,b)$ \\
\end{tabular}
}

\commandnote{
We can also interpret inverse of \linkterm{roles}{role_alc}:
\begin{itemize}
    \item If $\sint{\exists R.\varphi} = \set{x \in \mathcal{D} \mid \exists y. \tuple{x,y} \in \sint{R} \land y \in \sint{\varphi}}$
    
    Then $\sint{\exists R^{-1}.\varphi} = \set{x \in \mathcal{D} \mid \exists y. \tuple{y,x} \in \sint{R} \land y \in \sint{\varphi}}$
    \item Similarly, if $\sint{\forall R.\varphi} = \set{x \in \mathcal{D} \mid \forall y. \tuple{x,y} \in \sint{R} \Rightarrow y \in \sint{\varphi}}$
    
    Then $\sint{\forall R^{-1}.\varphi} = \set{x \in \mathcal{D} \mid \forall y. \tuple{y,x} \in \sint{R} \Rightarrow y \in \sint{\varphi}}$
\end{itemize}

For example, assume we have a simple $\mathcal{D} := \set{\text{Alice}, \text{Bob}, \text{Mary}, \text{Charlie}, \text{Ben}, \text{David}}$

And we have a \linkterm{role}{role_alc} $\text{has\_child} := \set{\tuple{\text{Alice}, \text{Bob}}, \tuple{\text{Alice}, \text{Mary}}, \tuple{\text{David}, \text{Ben}}, \tuple{\text{David}, \text{Charlie}}}$ 

Additionally, we have three concepts:
\begin{itemize}
    \item $\text{student} := \set{\text{Bob}, \text{Charlie}, \text{Ben}}$
    \item $\text{professor} := \set{\text{David}}$
    \item $\text{person} := \top$
\end{itemize}

Let's examine the following concepts:
\begin{itemize}
\item $\forall \text{has\_child}.\text{student} \leadsto \set{x \in \mathcal{D} \mid \forall y. \tuple{x,y} \in \sint{\text{has\_child}} \Rightarrow y \in \sint{\text{student}}} \leadsto \set{\text{David}}$
\item $\forall \text{has\_child}^{-1}.\text{professor} \leadsto \set{x \in \mathcal{D} \mid \forall y. \tuple{y,x} \in \sint{\text{has\_child}} \Rightarrow y \in \sint{\text{professor}}} \leadsto \set{\text{Charlie}, \text{Ben}}$
\item $\exists \text{has\_child}.\text{student} \leadsto \set{x \in \mathcal{D} \mid \exists y. \tuple{x,y} \in \sint{\text{has\_child}} \land y \in \sint{\text{student}}} \leadsto \set{\text{Alice}, \text{David}}$
\item $\exists \text{has\_child}^{-1}.\text{professor} \leadsto \set{x \in \mathcal{D} \mid \exists y. \tuple{y,x} \in \sint{\text{has\_child}} \land y \in \sint{\text{professor}}} \leadsto \set{\text{Charlie}, \text{Ben}}$  
\end{itemize}
}

\definition{$\mathcal{T}_{\mathcal{ALC}}$}{
The \linkterm{$\mathcal{ALC}$}{alc_grammar} \linkterm{tableau calculus}{tableau_calculus} $\mathcal{T}_{\mathcal{ALC}}$ acts on \linkterm{assertions}{abox_assertions_alc} $x:\varphi$ and $x \text{ R } y$ where $\varphi$ is a \linkterm{normalized}{normalized_formula_alc} \linkterm{$\mathcal{ALC}$}{alc_grammar} concept in \linkterm{NNF}{nnf_alc} with the following \linkterm{inference rules}{inference_rules_logic}
\begin{tcolorbox}[colback=white, colframe=black, sharp corners, boxrule=0.5pt]
\begin{multicols}{2}
    \noindent
    \begin{minipage}{\linewidth}
        \[
            \infer[\mathcal{T}_{\sqcap}]
            {x:\varphi \quad x:\psi}
            {x:\varphi \sqcap \psi}
        \]
    \end{minipage}

    \noindent
    \begin{minipage}{\linewidth}
        \[
            \infer[\mathcal{T}_{\sqcup}]
            {x:\varphi \mid x:\psi}
            {x:\varphi \sqcup \psi}
        \]
    \end{minipage}
\end{multicols}


\begin{multicols}{2}
    \noindent
    \begin{minipage}{\linewidth}
        \[
            \infer[\mathcal{T}_{\forall}]
            {y:\varphi}
            {x:\forall R. \varphi \quad x R y}
        \]
    \end{minipage}

    \noindent
    \begin{minipage}{\linewidth}
        \[
            \infer[\mathcal{T}_{\exists}]
            {x R y \quad y:\varphi}
            {x:\exists R. \varphi}
        \]
    \end{minipage}
\end{multicols}


\begin{minipage}{\linewidth}
    \[
        \infer[\mathcal{T}_{\bot}]
        {\bot}
        {x:\varphi \quad x:\overline{\varphi}}
    \]
\end{minipage}
\end{tcolorbox}
}{T_ALC}

\commandnote{
The $\forall$ rule states that if an individual $x$ belongs to $\forall R.\varphi$, which is the \linkterm{set}{def:set}: 
\[
\set{x \in \mathcal{D} \mid \forall y. \tuple{x,y} \in \sint{R} \Rightarrow y \in \sint{\varphi}}
\]

and we know that some $y$ is related to $x$, i.e. $\tuple{x,y} \in R$, then that $y$ must belong to the concept $\varphi$. 

For example, assume $\texttt{Alice}: \forall \texttt{has\_child.student}$, that means:
\[
\texttt{Alice} \in \set{x \in \mathcal{D} \mid \forall y. \tuple{x,y} \in \sint{\texttt{has\_child}} \Rightarrow y \in \sint{\texttt{student}}}
\]

If \texttt{Alice} has a child \texttt{Bob} $\leadsto \tuple{\texttt{Alice}, \texttt{Bob}} \in \texttt{has\_child}$

Then \texttt{Bob} must be a \texttt{student} $\leadsto \texttt{Bob} \in \sint{\texttt{student}}$
}

\commandnote{
The $\exists$ rule states that if $x$ belongs to the concept $\exists R. \varphi$, which is the \linkterm{set}{def:set}:
\[
\set{x \in \mathcal{D} \mid \exists y. \tuple{x,y} \in \sint{R} \land y \in \sint{\varphi}}
\]

then we infer that there must be at least a $y$ related to $x$ via $R$ ($\tuple{x,y} \in R$) and that $y$ must belong to the concept $\varphi$

For example: assume $\texttt{Alice}:\exists \texttt{has\_pet.dog}$ that means:
\[
\texttt{Alice} \in \set{x \in \mathcal{D} \mid \exists y. \tuple{x,y} \in \sint{\texttt{has\_pet}} \land y \in \sint{\texttt{dog}}}
\]

We can safely infer $\texttt{Alice} \texttt{ has\_pet } \texttt{y:dog}$ and $\texttt{y:dog}$
}

\minititle{\linkterm{$\mathcal{T}_{\mathcal{ALC}}$}{T_ALC} for \linkterm{consistency}{consistent_concept} checking}
\begin{itemize}
\item We convert the concept to \linkterm{NNF}{nnf_alc}
\item We initialize the tableau with $x:\varphi$ for an arbitrary $x$
\item We apply rules and expand 
\item We check if any branch remains open
\begin{itemize}
    \item if all branches close $\leadsto$ $\varphi$ is \linkterm{consistent}{consistent_concept} (\linkterm{unsatisfiable}{unsatisfiable_ls})
    \item if at least one open branch remains $\leadsto$ $\varphi$ is \linkterm{consistent}{consistent_concept} (\linkterm{satisfiable}{satisfiable_ls})
\end{itemize} 
\end{itemize}

\text{Example} Check \linkterm{consistency}{consistent_concept} of: $\forall \text{has\_child.man} \sqcap \exists \text{has\_child}.\overline{\text{man}}$

\begin{tabbing}
\begin{tabular}{|l|l|l|} \hline
1 & $x : \forall \text{has\_child.man} \sqcap \exists \text{has\_child}.\overline{\text{man}}$  & initial \\ \hline  
2 & $x:\forall \text{has\_child.man}$ & $\mathcal{T}_{\sqcap}$ on 1 \\ \hline
3 & $x:\exists \text{has\_child}.\overline{\text{man}}$ & $\mathcal{T}_{\sqcap}$ on 1 \\ \hline
4 & $x \text{has\_child} y$ & $\mathcal{T}_{\exists}$ on 3\\ \hline
5 & $y:\overline{\text{man}}$ &$\mathcal{T}_{\exists}$ on 3 \\ \hline
6 & $y:\text{man}$ &$\mathcal{T}_{\forall}$ on 2, 5 \\ \hline
7 & $\bot$ & $\mathcal{T}_{\bot}$ on 5,6 \\ \hline
\end{tabular}
\end{tabbing}

\textbf{Example: }Show satisfiability of: $\forall \text{has\_child}.(\text{ugrad} \sqcup \text{grad}) \sqcap \exists \text{has\_child}.\overline{\text{ugrad}}$

\begin{figure}[H]
\centering
\begin{tcolorbox}[colback=white, colframe=black, sharp corners, boxrule=0.5pt]
\centering
\begin{tikzpicture}[node distance=1ex]
\node (F) {$x:\forall \text{has\_child}.(\text{ugrad} \sqcup \text{grad}) \sqcap \exists \text{has\_child}.\overline{\text{ugrad}}$};

\node (F1) [below=of F] {$x:\forall \text{has\_child}.(\text{ugrad} \sqcup \text{grad})$};


\node (F2) [below=of F1] {$x:\exists \text{has\_child}.\overline{\text{ugrad}}$};

\node (F3) [below=of F2] {$x \text{ has\_child } y$};

\node (F4) [below=of F3] {$y:\overline{\text{ugrad}}$};

\node (F5) [below=of F4] {$y:(\text{ugrad} \sqcup \text{grad})$};

\node (F6) [below left=of F5] {$y:\text{ugrad}$};

\node (F7) [below right=of F5] {$y:\text{grad}$};

\node (F8) [below=of F6] {$\bot$};

\node (F9) [below=of F7] {$\square$ (open)};

\path (F5) edge[-] (F6);

\path (F5) edge[-] (F7);
\end{tikzpicture}

Since there is an open branch, we have a model that satisfy the concept, namely:

$x$ has a child $y$ that is graduate student.
\end{tcolorbox}
\end{figure}


\Lemma{
If $\varphi$ \linkterm{satisfiable}{satisfiable_ls}, then \linkterm{$\mathcal{T}_{\mathcal{ALC}}$}{T_ALC} terminates on $x:\varphi$ with \linkterm{open branch}{closed_branch}
}{}

\Lemma{
\linkterm{open branches}{closed_branch} of a \linkterm{saturated tableau}{saturated_tableau} for $\varphi$ induces models for $\varphi$
}{}

\Theorem{
\linkterm{$\mathcal{T}_{\mathcal{ALC}}$}{T_ALC} terminates
}{}

\Theorem{
The \linkterm{SAT}{SAT} problem for \linkterm{$\mathcal{ALC}$}{alc_grammar} is in PSPACE
}{}

\Theorem{
The \linkterm{SAT}{SAT} problem for \linkterm{$\mathcal{ALC}$}{alc_grammar} is PSPACE-Complete
}{}

\Theorem{
The \linkterm{$\mathcal{ALC}$}{alc_grammar} \linkterm{SAT}{SAT} problem is in EXPTIME
}{}

